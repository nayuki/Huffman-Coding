/*
 * Reference Huffman coding
 * Copyright (c) Project Nayuki
 *
 * https://www.nayuki.io/page/reference-huffman-coding
 * https://github.com/nayuki/Reference-Huffman-coding
 */

import java.io.*;
import java.util.Arrays;


/**
 * Decompression application using adaptive Huffman coding.
 * <p>Usage: java AdaptiveHuffmanDecompress InputFile OutputFile</p>
 * <p>This decompresses files generated by the "AdaptiveHuffmanCompress" application.</p>
 *
 * @author nayuki, hattoemi
 */
public final class AdaptiveHuffmanDecompress {

    /**
     * Command line main application function.
     * hattoemi: C language style,Java's implementation
     */
    public static void main(String[] args) throws IOException {
        final int virtualValue = 2;
        // Handle command line arguments
        if (args.length != virtualValue) {
            System.err.println("Usage: java AdaptiveHuffmanDecompress InputFile OutputFile");
            System.exit(1);
            return;
        }
        File inputFile = new File(args[0]);
        File outputFile = new File(args[1]);

        // Perform file decompression
        try (BitInputStream in = new BitInputStream(new BufferedInputStream(new FileInputStream(inputFile)))) {
            try (OutputStream out = new BufferedOutputStream(new FileOutputStream(outputFile))) {
                decompress(in, out);
            }
        }
    }


    /**
     * To allow unit testing, this method is package-private instead of private.
     */
    static void decompress(BitInputStream in, OutputStream out) throws IOException {
        int[] initFrequency = new int[257];
        Arrays.fill(initFrequency, 1);

        FrequencyTable frequency = new FrequencyTable(initFrequency);
        HuffmanDecoder dec = new HuffmanDecoder(in);
        // Use same algorithm as the compressor
        dec.codeTree = frequency.buildCodeTree();
        // Number of bytes written to the output file
        int count = 0;
        while (true) {
            // Decode and write one byte
            int symbol = dec.read();
            // EOF symbol
            if (symbol == 256) {
                break;
            }
            out.write(symbol);
            count++;

            // Update the frequency table and possibly the code tree
            frequency.increment(symbol);
            /* Update code tree
             * hattoemi: Don't make complex logical decisions in conditional judgments
             * 262144 = 2^18
             */
            final boolean inLimit = (count < 262144 && isPowerOf2(count) || count % 262144 == 0);
            if (inLimit) {
                dec.codeTree = frequency.buildCodeTree();
            }
            // Reset frequency table
            if (count % 262144 == 0) {
                frequency = new FrequencyTable(initFrequency);
            }
        }
    }


    private static boolean isPowerOf2(int x) {
        return x > 0 && Integer.bitCount(x) == 1;
    }

}
